Index: drivers/drivers.c
===================================================================
--- drivers/drivers.c	(revision 30)
+++ drivers/drivers.c	(working copy)
@@ -130,6 +130,7 @@
   UINTN                        StringIndex;
   UINTN                        Index;
   CHAR8                        *Language;
+  CHAR8                        *PlatformLanguage;
   UINTN                        DriverImageHandleCount;
   EFI_HANDLE                   *DriverImageHandleBuffer;
   UINTN                        HandleIndex;
@@ -152,6 +153,7 @@
   SHELL_VAR_CHECK_PACKAGE      ChkPck;
 
   Language                = NULL;
+  PlatformLanguage        = NULL;
   DriverImageHandleCount  = 0;
   DriverImageHandleBuffer = NULL;
   IsHelp                  = FALSE;
@@ -241,7 +243,7 @@
       goto Done;
     }
 
-    Language = LibGetVariableLang ();
+    Language = LibGetVariable (L"Lang", &gEfiGlobalVariableGuid);
     if (Language == NULL) {
       Language = (CHAR8 *)AllocateZeroPool(strlena(LanguageCodeEnglish) + 1);
       if (Language == NULL) {
@@ -250,6 +252,15 @@
       strcpya(Language, LanguageCodeEnglish);
     }
 
+    PlatformLanguage = LibGetVariable (L"PlatformLang", &gEfiGlobalVariableGuid);
+    if (PlatformLanguage == NULL) {
+      PlatformLanguage = (CHAR8 *)AllocateZeroPool(strlena(PlatformLanguageCodeEnglish) + 1);
+      if (PlatformLanguage == NULL) {
+        return EFI_OUT_OF_RESOURCES;
+      }
+      strcpya(PlatformLanguage, PlatformLanguageCodeEnglish);
+    }
+
     Item = LibCheckVarGetFlag (&ChkPck, L"-l");
     if (Item) {
       if (Language != NULL) {
@@ -314,14 +325,6 @@
                   EFI_OPEN_PROTOCOL_GET_PROTOCOL
                   );
 
-    ComponentName  = NULL;
-    ComponentName2 = NULL;
-    Status = LibGetComponentNameProtocol (
-               DriverImageHandleBuffer[Index],
-               &ComponentName,
-               &ComponentName2
-               );
-
     DiagnosticsStatus = BS->OpenProtocol (
                               DriverImageHandleBuffer[Index],
                               &gEfiDriverDiagnostics2ProtocolGuid,
@@ -418,37 +421,73 @@
     } else {
       PrintToken (STRING_TOKEN (STR_SHELLENV_PROTID_ONE_VAR_D), HiiHandle, NumberOfChildren);
     }
-
-    Status     = EFI_SUCCESS;
+    
     DriverName = L"<UNKNOWN>";
-    SupportedLanguage = NULL;
-    if (ComponentName != NULL) {
-      if (ComponentName->GetDriverName != NULL) {
-        SupportedLanguage = LibConvertSupportedLanguage (ComponentName->SupportedLanguages, Language);
+    Status = BS->OpenProtocol (
+                   DriverImageHandleBuffer[Index],
+                   &gEfiComponentName2ProtocolGuid,
+                   (VOID **) &ComponentName2,
+                   NULL,
+                   NULL,
+                   EFI_OPEN_PROTOCOL_GET_PROTOCOL
+                   );
+    if (!EFI_ERROR (Status)) {
+      //
+      // Driver has Component Name 2 Protocol is available, we get the
+      // driver name var RFC 3066 language code
+      // 
+      Status = ComponentName2->GetDriverName (
+                                 ComponentName2,
+                                 PlatformLanguage,
+                                 &DriverName
+                                 );
+      if (EFI_ERROR (Status)) {
+        //
+        // Current RFC3066 language code fails, we then extract the supported
+        // language from Component Name 2 protocol interface.
+        // 
+        SupportedLanguage =  ExtractSupportedLanguage(ComponentName2->SupportedLanguages, Language);
+        if (SupportedLanguage != NULL) {
+          Status = ComponentName2->GetDriverName (
+                                     ComponentName2,
+                                     SupportedLanguage,
+                                     &DriverName
+                                     );
+          FreePool(SupportedLanguage);
+        }
+      }
+    }
+    if (EFI_ERROR (Status)) {
+      //
+      // In case Component Name 2 protocol is not available or some error occurs
+      // when getting driver name from Component Name 2 protocol, we get driver
+      // name from Component Name protocol.
+      // 
+      Status = BS->OpenProtocol (
+                     DriverImageHandleBuffer[Index],
+                     &gEfiComponentNameProtocolGuid,
+                     (VOID **) &ComponentName,
+                     NULL,
+                     NULL,
+                     EFI_OPEN_PROTOCOL_GET_PROTOCOL
+                     );
+      if (!EFI_ERROR (Status)) {
         Status = ComponentName->GetDriverName (
                                   ComponentName,
-                                  SupportedLanguage,
+                                  Language,
                                   &DriverName
                                   );
       }
-    } else if (ComponentName2 != NULL) {
-      if (ComponentName2->GetDriverName != NULL) {
-        SupportedLanguage = LibConvertSupportedLanguage (ComponentName2->SupportedLanguages, Language);
-        Status = ComponentName2->GetDriverName (
-                                   ComponentName2,
-                                   SupportedLanguage,
-                                   &DriverName
-                                   );
-      }
     }
-    if (SupportedLanguage != NULL) {
-      FreePool (SupportedLanguage);
-    }
-
     if (EFI_ERROR (Status)) {
+      //
+      // Fails to get driver name from either Component Name 2 & Component Name
+      // Protocol, we show "<UNKNOWN>" string as driver name.
+      // 
       DriverName = L"<UNKNOWN>";
     }
 
+ 
     for (StringIndex = 0; StringIndex < StrLen (DriverName) && StringIndex < 35; StringIndex++) {
       FormattedDriverName[StringIndex] = DriverName[StringIndex];
     }
@@ -491,6 +530,10 @@
     FreePool (Language);
   }
 
+  if (PlatformLanguage != NULL) {
+    FreePool (PlatformLanguage);
+  }
+
   ShellCloseHandleEnumerator ();
   LibCheckVarFreeVarList (&ChkPck);
   LibUnInitializeStrings ();
Index: edit/libEditor.c
===================================================================
--- edit/libEditor.c	(revision 30)
+++ edit/libEditor.c	(working copy)
@@ -88,8 +88,6 @@
   )
 {
   EFI_STATUS  Status;
-  EFI_HANDLE  *HandleBuffer;
-  UINTN       HandleCount;
 
   //
   // basic initialization
@@ -117,38 +115,22 @@
         );
 
   //
-  // Find mouse
+  // Find mouse in System Table ConsoleInHandle
   //
-  HandleBuffer = NULL;
-  Status = LibLocateHandle (
-            ByProtocol,
-            &gEfiPrimaryConsoleInDeviceGuid,
-            NULL,
-            &HandleCount,
-            &HandleBuffer
-            );
+  Status = BS->HandleProtocol (
+                In,
+                &gEfiSimplePointerProtocolGuid,
+                &MainEditor.MouseInterface
+                );
 
-  if (!EFI_ERROR (Status)) {
-    if (HandleCount > 0) {
-      Status = BS->HandleProtocol (
-                    HandleBuffer[0],
-                    &gEfiSimplePointerProtocolGuid,
-                    &MainEditor.MouseInterface
-                    );
-
-      if (EFI_ERROR (Status)) {
-        MainEditor.MouseInterface = NULL;
-      } else {
-        MainEditor.MouseAccumulatorX  = 0;
-        MainEditor.MouseAccumulatorY  = 0;
-        MainEditor.MouseSupported     = TRUE;
-      }
-    }
+  if (EFI_ERROR (Status)) {
+    MainEditor.MouseInterface = NULL;
+  } else {
+    MainEditor.MouseAccumulatorX  = 0;
+    MainEditor.MouseAccumulatorY  = 0;
+    MainEditor.MouseSupported     = TRUE;
   }
 
-  if (HandleBuffer) {
-    FreePool (HandleBuffer);
-  }
   //
   // below will call the five components' init function
   //
Index: edit/libFileBuffer.c
===================================================================
--- edit/libFileBuffer.c	(revision 30)
+++ edit/libFileBuffer.c	(working copy)
@@ -735,7 +735,7 @@
   UINTN                           LineSize;
   VOID                            *Buffer;
   CHAR16                          *UnicodeBuffer;
-  CHAR8                           *AsciiBuffer;
+  UINT8                           *AsciiBuffer;
   UINTN                           FileSize;
   EFI_FILE_HANDLE                 Handle;
   BOOLEAN                         CreateFile;
@@ -1047,7 +1047,7 @@
       //
       // Unicode file
       //
-      if (AsciiBuffer[0] == 0xff && AsciiBuffer[1] == 0xfe) {
+      if ((FileSize >= 2) && (*((UINT16 *) Buffer) == EFI_UNICODE_BYTE_ORDER_MARK)) {
         //
         // Unicode file's size should be even
         //
Index: hexedit/libEditor.c
===================================================================
--- hexedit/libEditor.c	(revision 30)
+++ hexedit/libEditor.c	(working copy)
@@ -100,8 +100,6 @@
 --*/
 {
   EFI_STATUS  Status;
-  EFI_HANDLE  *HandleBuffer;
-  UINTN       HandleCount;
 
   //
   // basic initialization
@@ -129,36 +127,19 @@
         &(HMainEditor.ScreenSize.Row)
         );
 
-  HandleBuffer = NULL;
-  Status = LibLocateHandle (
-            ByProtocol,
-            &gEfiPrimaryConsoleInDeviceGuid,
-            NULL,
-            &HandleCount,
-            &HandleBuffer
-            );
-
-  if (!EFI_ERROR (Status)) {
-
-    if (HandleCount > 0) {
-      Status = BS->HandleProtocol (
-                    HandleBuffer[0],
-                    &gEfiSimplePointerProtocolGuid,
-                    &HMainEditor.MouseInterface
-                    );
-      if (EFI_ERROR (Status)) {
-        HMainEditor.MouseInterface = NULL;
-      } else {
-        HMainEditor.MouseAccumulatorX = 0;
-        HMainEditor.MouseAccumulatorY = 0;
-        HMainEditor.MouseSupported    = TRUE;
-      }
-    }
+  Status = BS->HandleProtocol (
+                In,
+                &gEfiSimplePointerProtocolGuid,
+                &HMainEditor.MouseInterface
+                );
+  if (EFI_ERROR (Status)) {
+    HMainEditor.MouseInterface = NULL;
+  } else {
+    HMainEditor.MouseAccumulatorX = 0;
+    HMainEditor.MouseAccumulatorY = 0;
+    HMainEditor.MouseSupported    = TRUE;
   }
 
-  if (HandleBuffer != NULL) {
-    FreePool (HandleBuffer);
-  }
   //
   // below will call the five components' init function
   //
Index: Library/EfiShellLib.h
===================================================================
--- Library/EfiShellLib.h	(revision 30)
+++ Library/EfiShellLib.h	(working copy)
@@ -174,22 +174,23 @@
 //
 //  Environment variable name constants
 //
-#define VarLanguageCodes    L"LangCodes"
-#define VarLanguage         L"Lang"
-#define VarTimeout          L"Timeout"
-#define VarConsoleIn        L"ConIn"
-#define VarConsoleOut       L"ConOut"
-#define VarErrorOut         L"ErrOut"
-#define VarBootOption       L"Boot%04x"
-#define VarBootOrder        L"BootOrder"
-#define VarBootNext         L"BootNext"
-#define VarBootCurrent      L"BootCurrent"
-#define VarDriverOption     L"Driver%04x"
-#define VarDriverOrder      L"DriverOrder"
-#define VarConsoleInpDev    L"ConInDev"
-#define VarConsoleOutDev    L"ConOutDev"
-#define VarErrorOutDev      L"ErrOutDev"
-#define LanguageCodeEnglish "eng"
+#define VarLanguageCodes            L"LangCodes"
+#define VarLanguage                 L"Lang"
+#define VarTimeout                  L"Timeout"
+#define VarConsoleIn                L"ConIn"
+#define VarConsoleOut               L"ConOut"
+#define VarErrorOut                 L"ErrOut"
+#define VarBootOption               L"Boot%04x"
+#define VarBootOrder                L"BootOrder"
+#define VarBootNext                 L"BootNext"
+#define VarBootCurrent              L"BootCurrent"
+#define VarDriverOption             L"Driver%04x"
+#define VarDriverOrder              L"DriverOrder"
+#define VarConsoleInpDev            L"ConInDev"
+#define VarConsoleOutDev            L"ConOutDev"
+#define VarErrorOutDev              L"ErrOutDev"
+#define LanguageCodeEnglish         "eng"
+#define PlatformLanguageCodeEnglish "en-US"
 
 #define ISO_639_2_ENTRY_SIZE  3
 #define RFC_3066_ENTRY_SIZE   12
@@ -333,4 +334,10 @@
   IN CHAR8                           *LangCode
   );
 
+CHAR8 *
+ExtractSupportedLanguage (
+  IN CONST CHAR8   *SupportedLanguages,
+  IN CONST CHAR8   *Language
+  );
+
 #endif
Index: Library/Misc.c
===================================================================
--- Library/Misc.c	(revision 30)
+++ Library/Misc.c	(working copy)
@@ -1905,13 +1905,13 @@
   IN VOID         *UserData
   )
 {
-  CHAR8 *Data;
+  UINT8 *Data;
 
   CHAR8 Val[50];
 
   CHAR8 Str[20];
 
-  CHAR8 c;
+  UINT8 c;
   UINTN Size;
   UINTN Index;
   
@@ -2271,3 +2271,76 @@
   }
   return Lang;
 }
+
+CHAR8 *
+ExtractSupportedLanguage (
+  IN CONST CHAR8   *SupportedLanguages,
+  IN CONST CHAR8   *Language
+  )
+/*++
+
+  Routine Description:
+
+    This function matches the major language code (first two characters) in the
+    SupportedLanguages. The first language code in the SupportedLanguages that
+    matches first two characters of the input Language is returned. If there is no
+    such match, then NULL is returned.
+
+  Arguments:
+
+    SupportedLanguages    -   A Null-terminated ASCII string that contains one
+                              or more supported language codes. 
+
+    LangCode              -   A pointer to a Null-terminated ASCII string
+                              array indicating the RFC 3066 language.
+
+  Returns:
+
+    The RFC3066 language code that matches the major language. 
+
+--*/
+{
+  CONST CHAR8      *CurrentLanguage;
+  CHAR8            *SupportedLanguage;
+  UINTN            LanguageLen;
+
+  CurrentLanguage = SupportedLanguages;
+
+  while (CurrentLanguage != '\0') {
+    //
+    // Search till the end of current language.
+    // 
+    LanguageLen = 0;
+    while (CurrentLanguage[LanguageLen] != ';' && CurrentLanguage[LanguageLen] != '\0') {
+      LanguageLen++;
+    }
+
+    //
+    // should use AsciiStrnCmp(CurrentLanguage, Language, 2) == 0
+    // 
+    if ((CurrentLanguage[0] == Language[0]) && (CurrentLanguage[1] == Language[1])) {
+      //
+      // Match the major language code, then return a new copy of
+      // NULL-terminated SupportedLanguage.
+      //
+      SupportedLanguage = AllocatePool (LanguageLen + 1);
+      CopyMem (SupportedLanguage, (VOID *) CurrentLanguage, LanguageLen);
+
+      SupportedLanguage[LanguageLen] = '\0';
+
+      return SupportedLanguage;
+    }
+    //
+    // Make CurrentLangue point to the next candiate language code.
+    // 
+    CurrentLanguage += LanguageLen;
+    if (*CurrentLanguage == ';') {
+      CurrentLanguage++;
+    }
+  }
+
+  return NULL;
+}
+
+
+
Index: shellenv/batch.c
===================================================================
--- shellenv/batch.c	(revision 30)
+++ shellenv/batch.c	(working copy)
@@ -2074,17 +2074,17 @@
 --*/
 {
   //
-  // UNICODE byte-order-mark is two bytes
+  // UNICODE byte-order-mark is 16 bits
   //
-  CHAR8       Buffer8[2];
+  UINT16      Uint16;
   UINTN       BufSize;
   EFI_STATUS  Status;
 
   //
   //  Read the first two bytes to check for byte order mark
   //
-  BufSize = sizeof (Buffer8);
-  Status  = File->Read (File, &BufSize, Buffer8);
+  BufSize = sizeof (Uint16);
+  Status  = File->Read (File, &BufSize, &Uint16);
   if (EFI_ERROR (Status)) {
     return Status;
   }
@@ -2098,9 +2098,8 @@
   //  otherwise assume it is ASCII.  UNICODE byte order mark on
   //  IA little endian is first byte 0xff and second byte 0xfe
   //
-  if ((Buffer8[0] | (Buffer8[1] << 8)) == EFI_UNICODE_BYTE_ORDER_MARK) {
+  if ((BufSize == 2) && (Uint16 == EFI_UNICODE_BYTE_ORDER_MARK)) {
     *IsAscii = FALSE;
-
   } else {
     *IsAscii = TRUE;
   }
Index: shellenv/Connect.c
===================================================================
--- shellenv/Connect.c	(revision 30)
+++ shellenv/Connect.c	(working copy)
@@ -831,6 +831,16 @@
     return Status;
   }
 
+  //
+  // Close proxy console before disconnect all devices.
+  //
+  SEnvCloseConsoleProxy (
+    ST->ConsoleInHandle,
+    &ST->ConIn,
+    ST->ConsoleOutHandle,
+    &ST->ConOut
+    );
+
   for (Index = 0; Index < AllHandleCount; Index++) {
     //
     // Check whether the handle is still in handle database
@@ -1004,7 +1014,6 @@
 VOID
 SEnvConnectConsole (
   CHAR16      *VariableName,
-  EFI_GUID    *PrimaryGuid,
   EFI_GUID    *ConsoleGuid,
   EFI_HANDLE  *ConsoleHandle,
   VOID        **ConsoleInterface
@@ -1018,27 +1027,36 @@
   EFI_HANDLE                *AllHandleBuffer;
   VOID                      *Interface;
 
-  *ConsoleHandle    = NULL;
-  *ConsoleInterface = NULL;
   ConsoleIndex      = 0;
+  AllHandleBuffer   = NULL;
 
   DevicePath        = LibGetVariable (VariableName, &gEfiGlobalVariableGuid);
-  if (DevicePath != NULL) {
-    SEnvConnectDevicePath (DevicePath);
-    FreePool (DevicePath);
+  if (DevicePath == NULL) {
+    //
+    // If no any device defined in EFI variable, do nothing
+    //
+    return;
   }
 
-  AllHandleBuffer = NULL;
-  Status = BS->LocateHandleBuffer (
-                ByProtocol,
-                PrimaryGuid,
-                NULL,
-                &AllHandleCount,
-                &AllHandleBuffer
-                );
-  if (!EFI_ERROR (Status) && AllHandleCount > 0) {
-    *ConsoleHandle = AllHandleBuffer[0];
-  } else if (*ConsoleHandle == NULL) {
+  //
+  // Connect all console devices
+  //
+  SEnvConnectDevicePath (DevicePath);
+  FreePool (DevicePath);
+
+  Status = EFI_NOT_FOUND;
+  //
+  // Check ConsoleHandle validation whatever it was updated or not.
+  //
+  if (*ConsoleHandle != NULL) {
+    Status = BS->HandleProtocol (
+                  *ConsoleHandle,
+                  ConsoleGuid,
+                  &Interface
+                  );
+  } 
+
+  if (EFI_ERROR (Status)) {
     AllHandleBuffer = NULL;
     Status = BS->LocateHandleBuffer (
                   ByProtocol,
@@ -1063,16 +1081,16 @@
                       &gEfiDevicePathProtocolGuid,
                       &Interface
                       );
-        if (EFI_ERROR (Status)) {
+        if (!EFI_ERROR (Status)) {
           ConsoleIndex = Index;
           break;
         }
       }
+      
+      *ConsoleHandle = AllHandleBuffer[ConsoleIndex];
     }
   }
 
-  *ConsoleHandle = AllHandleBuffer[ConsoleIndex];
-
   if (*ConsoleHandle != NULL) {
     BS->HandleProtocol (
           *ConsoleHandle,
@@ -1081,7 +1099,7 @@
           );
   }
 
-  if (AllHandleBuffer) {
+  if (AllHandleBuffer != NULL) {
     FreePool (AllHandleBuffer);
   }
 }
@@ -1189,8 +1207,7 @@
   EFI_STATUS  Status;
 
   //
-  // Check current ConIn and ConOut to ensure it is the ConsoleProxy
-  // Otherwise, the Console should not be close
+  // Check current ConIn and ConOut to judge it is the ConsoleProxy
   //
   Status = SEnvCheckConsoleProxy (
             ST->ConsoleInHandle,
@@ -1203,23 +1220,21 @@
   // Indicate the Console is replaced by redirection operation
   // It is not safe to connect Console here
   //
-  if (EFI_ERROR (Status)) {
-    return ;
+  if (!EFI_ERROR (Status)) {
+    //
+    // It is proxy console, to prevent the proxy console form being restored to original console,
+    // close it temporary before connect all console
+    //
+    SEnvCloseConsoleProxy (
+      ST->ConsoleInHandle,
+      &ST->ConIn,
+      ST->ConsoleOutHandle,
+      &ST->ConOut
+      );
   }
-  //
-  // To prevent the proxy console form being restored to original console,
-  // close it temporary before connect all console
-  //
-  SEnvCloseConsoleProxy (
-    ST->ConsoleInHandle,
-    &ST->ConIn,
-    ST->ConsoleOutHandle,
-    &ST->ConOut
-    );
 
   SEnvConnectConsole (
     VarErrorOut,
-    &gEfiPrimaryStandardErrorDeviceGuid,
     &gEfiSimpleTextOutProtocolGuid,
     &ST->StandardErrorHandle,
     (VOID **) &ST->StdErr
@@ -1227,7 +1242,6 @@
 
   SEnvConnectConsole (
     VarConsoleOut,
-    &gEfiPrimaryConsoleOutDeviceGuid,
     &gEfiSimpleTextOutProtocolGuid,
     &ST->ConsoleOutHandle,
     (VOID **) &ST->ConOut
@@ -1235,7 +1249,6 @@
 
   SEnvConnectConsole (
     VarConsoleIn,
-    &gEfiPrimaryConsoleInDeviceGuid,
     &gEfiSimpleTextInProtocolGuid,
     &ST->ConsoleInHandle,
     (VOID **) &ST->ConIn
@@ -1254,6 +1267,8 @@
   SetCrc (&ST->Hdr);
 }
 
+
+
 EFI_STATUS
 EFIAPI
 SEnvCmdReconnect (
Index: SmbiosView/PrintInfo.c
===================================================================
--- SmbiosView/PrintInfo.c	(revision 30)
+++ SmbiosView/PrintInfo.c	(working copy)
@@ -1779,7 +1779,7 @@
   //
   // MaxSize is determined by follow formula
   //
-  MaxSize = 1 << Size;
+  MaxSize = (UINTN) 1 << Size;
   PrintToken (STRING_TOKEN (STR_SMBIOSVIEW_PRINTINFO_ONE_VAR_MB), HiiHandle, MaxSize);
 
   if (Option >= SHOW_DETAIL) {
Index: SmbiosView/Smbios.h
===================================================================
--- SmbiosView/Smbios.h	(revision 30)
+++ SmbiosView/Smbios.h	(working copy)
@@ -34,11 +34,6 @@
 
 extern EFI_HII_HANDLE HiiHandle;
 
-#define EFI_SMBIOS_TABLE_GUID \
-  { \
-    0xeb9d2d31, 0x2d88, 0x11d3, 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d \
-  }
 
-extern EFI_GUID       gEfiSmbiosTableGuid;
 
 #endif
